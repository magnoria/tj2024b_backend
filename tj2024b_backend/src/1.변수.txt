[변수]
	- 변하는 수
	- 값을 넣을 수 있는 빈 그릇과 같습니다.
	1. 변수 형태
		자료형 변수명 = 리터럴;
		
	2. 변수 선언
		1. 선언 : 자료형 변수명;
		2. 초기화 : 자료형 변수명 = 리터럴;
		
	3. 변수명 주의할점
		1. 숫자로 시작x
		2. 특수문자 _와 $ 사용하고 띄어쓰기x
		3. 키워드(예약어 ) : if for int 등등
		* 카멜 표기법 : 두번째 단어는 첫글자를 대문자
			 numberofstudent - > numverOfstudent
			 
	4. 변수의 값 호출 
		변수명
	5. 변수의 값 수정
		변수명 = 새로운 값
			 
[리터럴]
	- 데이터 그자체, 키보드로 부터 입력한 자료 (언어마다 리터럴이 다르다)
	- 자바 리터럴 : 논리 booldean, 문자char , 정수 int , 실수double			 
[자료형]
	- 타입 , 자료의 형식, 자료를 분류하는 방법
	
		// 자료형 /타입 / 분류 : 데이터를 나누는 방법 
		1. 목적 : 타입의 메모리를 저장범위를 고려하여 저장할 데이터에 적합하게 선택하여 사용하므로 효율성을 높일 수 있다.
		
		 - 자바 기본 타입 , 8가지 존재(+String클래스타입)
		 
		 	   	[키워드]		[용량]			[사용범위]
		 
		 [논리]	boolean     1바이트 		true혹은false 만 저장할수있다.   자바는 0또는 1 이기에 비트 이지만 자바는 바이트 단위이므로 바이트로 표현
		 
		 [문자]	char    	2바이트 		유니코드 , 작은따음표로 감싼 것을 저장할수있다 , 'A'    문자인 유니코드가 2바이트
		 		-String     n바이트 		문자열클래스, 큰따음표로 감산 문자를 저장할 수 있다.   "ABC" 기본타입이아닌 조금 다른것 객체임
		 		
		 [정수]  byte        1바이트		-128 ~ +127 저장 0도 포함되서
				short		2바이트		+-3만정도 저장
				int			4바이트		+-21억정도 저장    , 만든사람이 정수의 기본타입 (리터럴)을 바이트로 정함, 키보드로 입력한 정수는 다 int     리터럴정수(키보드로 입력받은 정수)
				long		8바이트		+-21억정도 저장	, 리터럴정수뒤에 L/l 붙이기
		 
		 [실수, 부동소수점]
		 		float(뜨다)	4바이트   	소수점8자리 표현   ,실수 리터럴 뒤에 F/f붙이기
		 		double		8바이트		소수점17자리 표현  , 리터럴실수, 실수중에 기본타입
		 		
		 		*왜? 타입을 여러가지 구분해서 범위맞게 사용하라고 할까? 메모리 효율적으로 적절하게 선택하여 사용하려고	(설계)	
		 		
		 		
		 		
		 		
[부동 소수점]
	* 0과 1 사이의 실수는 끝없는 무한대 표현 가능하므로 , 컴퓨터 한계를 만들었다.
		-지수부 : 숫자의 크기를 조정하는 역할 ex] 몇승이 될건지
		
		-가수부 : 숫자의 유효 자릿수를 표현 ex] 숫자 자체
		
	float : 부호1비트,  지수부 8 , 가수부 23비트									- float 4바이트
	douuble :부호1비트, 지수부11비트, 가수부 52비트  								- double 8바이트
			ex] 데이터 : 1000000, 가수 : 1, 지수 : 6 (10을 6번 곱해야함), 1.0 *10^6
		
		-실제 연산이 중요한 부분에 업무에서는 실수타입 사용하는데 한계(오차존재), 해결법 라이브러리 BigDecimal 또는 문자열 처리
	
		
	
	
		1. 2진수로 표현시 : -110.01
		2. 부호 : 0(양수) 1(음수)이기에 1로 표현된다
		
		
		
		
		
**************************************************************************************

[변수]
	- 변하는 수 
	- 값을 넣을 수 있는 빈 그릇과 같습니다.
	1. 변수 형태 
		자료형 변수명 = 리터럴;
	2. 변수 선언 
		1. 선언 : 자료형 변수명;
		2. 초기화 : 자료형 변수명 = 리터럴;
	3. 변수명 주의할점
		1. 숫자로 시작 불가능하다.
		2. 특수문자 _ 와 $ 사용 하고 띄어쓰기 불가능하다
		3. 키워드(예약어) : if for int 등등 불가능하다.
		* 카멜표기법 : 소문자로 시작하고 두번째 단어는 첫글자를 대문자 한다.
		numberofStudent -> numberOfStudent
	4. 변수의 값 호출 
		변수명
		
	5. 변수의 값 수정 
		변수명 = 새로운값
		
[리터럴]
	- 데이터 그자체, 키보드로 부터 입력한 자료 
	- 자바 리터럴은 : 논리boolean , 문자char , 정수int , 실수double
	
[ 자료형/타입 ]
	- 타입 , 자료의 형식 , 자료를 분류하는 방법
	1. 목적 : 타입의 저장범위를 고려하여 저장할 데이터를 적합하게 선택하여 사용하므로 효율성을 높일수 있다. ( 설계 )
	2. 종류 
	- 자바 기본 타입 , 8가지 (+String클래스타입)
			[키워드]		[용량]		[저장범위]
 	[논리]	boolean		1바이트		true 혹은 false 
	
	[문자]	char		2바이트		유니코드 , 작은따옴표로 감싼 문자		, 'A'
			*String		N바이트		문자열클래스 , 큰따옴표로 감싼 문자열	, "ABC"
			
	[정수]	byte		1바이트		-128 ~ +127 저장 
			short		2바이트		+-3만정도 저장 
			int 		4바이트		+-21억정도 저장 , 리터럴정수(키보드로 입력한 정수) , 정수중에 기본타입
			long		8바이트		+-21억이상 저장 , 리터럴정수 뒤에 L/l 붙이기 
			
	[실수 , 부동소수점 ]
			float		4바이트		소수점8자리 표현 , 실수리터럴 뒤에 F/f 붙이기 
			double		8바이트		소수점17자리 표현 , 실수리터럴 , 실수중에 기본타입

[ 부동 소수점 ]
	* 0 과 1 사이의 실수는 끝없는 무한대 표현 가능하므로 , 컴퓨터 한계를 만들었다.
	- 지수부 : 숫자의 크기를 조정하는 역할 ex] 몇승
	- 가수부 : 숫자의 유효 자릿수를 표현 ex] 숫자 자체
	float : 부호1비트, 지수부8비트 , 가수부23비트
	double : 부호1비트, 지수부11비트 , 가수부52비트 
		ex] 데이터 : 1000000 , 가수 : 1 , 지수 : 6 ( 10을 6번 곱해야 함 ) , 1.0*10^6
	- 실제 연산이 중요한 부분에 업무에서는 실수타입 사용하는데 한계(오차) , 해결법:라이브러리 BigDecimal 또는 문자열 처리 
	
[ 소수 자릿수를 이동하는 방법 ]
	100.0 * 10 : 1000.0
	100.0 / 10 : 10.0
	
[ 상수 ]
	- 초기화 이후 변하지 않는 값
	- final키워드
	- 상수명은 관례적으로 대문자로 사용한다.	

[ 리터럴 ]
	- 개발자가 키보드로부터 입력한 숫자,문자,논리 등등 일컫는 말
	- 자바는 이러한 리터럴값들을 상수풀(메모리공간)이라는 곳에서 *상수*로 저장 한다.

[ 타입변환 ]
	1. 자동 타입 변환 , 묵시적 형 변환 
		- 1.메모리 크기가 작은 것 부터 큰 순으로 변환
		- 2.데이터의 손실이 없다.
		- 3.연산(계산) 중에 큰 값으로 변환된다.( 메모리 손실 방지 )
		- byte -> short , char -> int -> long -> float -> double 
		+ 연산중에 묵시적 형변환  , 연산시 피연산자중에 더 큰 타입으로 결과를 반환한다.
			byte + byte => int	, 예외] byte와 short 연산 결과는 무조건 int로 반환된다.
			byte + short => int 	, 
			int + int => int 
			int + long => long 
			int + float => float 
			float + double => double 
			
	2. 강제 타입 변환 , 명시적 형 변환 , 캐스팅 
		- 1. 메모리 크기가 큰것 부터 작은 순으로 변환 
		- 2. 데이터의 (허용범위 외)손실이 있을수도 있다.
		- 3. (변환할타입명)변수명 , (변환할타입명)리터럴값
		- double -> float -> long -> int -> short , char -> byte
 
	
	
	
	
	